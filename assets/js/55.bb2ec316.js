(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{371:function(v,_,t){"use strict";t.r(_);var a=t(12),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[v._v("#")]),v._v(" 设计原则")]),v._v(" "),_("h2",{attrs:{id:"单一职责"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单一职责"}},[v._v("#")]),v._v(" 单一职责")]),v._v(" "),_("p",[v._v("一个类只负责一个功能领域中的相应职责")]),v._v(" "),_("p",[v._v("几乎所有程序员都知道 "),_("code",[v._v("高内聚、低耦合")]),v._v("，应该把相关代码放一起")]),v._v(" "),_("p",[v._v("关键句")]),v._v(" "),_("ul",[_("li",[v._v("当你修改 A 功能，B 功能不应该被牵涉修改")]),v._v(" "),_("li",[v._v("比较难命名的肯定就对职责定义不清晰")]),v._v(" "),_("li",[v._v("代码行过多")])]),v._v(" "),_("h2",{attrs:{id:"接口隔离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离"}},[v._v("#")]),v._v(" 接口隔离")]),v._v(" "),_("p",[v._v("类之间的依赖关系应该建立在最小的接口上")]),v._v(" "),_("p",[v._v("接口隔离和单一职责的区别：")]),v._v(" "),_("p",[v._v("范围区别：单一职责原则是针对模块、类、接口的设计，接口隔离原则相对单一职责更侧重接口的设计。")]),v._v(" "),_("p",[v._v("接口隔离主要面向调用者：调用者只使用部分接口或者接口的部分功能，那接口的设计就不够单一。")]),v._v(" "),_("p",[v._v("关键句")]),v._v(" "),_("ul",[_("li",[v._v("必须满足 "),_("code",[v._v("单一职责原则")]),v._v(",在满足高内聚的前提下，接口中的方法越少越好")])]),v._v(" "),_("h2",{attrs:{id:"开闭原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[v._v("#")]),v._v(" 开闭原则")]),v._v(" "),_("p",[v._v("对扩展开放，对修改关闭")]),v._v(" "),_("p",[v._v("关键句")]),v._v(" "),_("ul",[_("li",[v._v("开闭原则不是完全杜绝修改，而是以最小的修改代码代价来完成新功能开发")]),v._v(" "),_("li",[v._v("实现开闭原则的关键就是抽象化")]),v._v(" "),_("li",[v._v("找到系统的可变因素,将它封装起来")])]),v._v(" "),_("h2",{attrs:{id:"里氏替换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换"}},[v._v("#")]),v._v(" 里氏替换")]),v._v(" "),_("p",[v._v("所有引用基类的地方必须能透明地使用其子类的对象")]),v._v(" "),_("p",[v._v("通俗的来说：子类可以扩展父类的功能，但不能改变父类原有的功能")]),v._v(" "),_("h2",{attrs:{id:"依赖倒置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置"}},[v._v("#")]),v._v(" 依赖倒置")]),v._v(" "),_("p",[v._v("依赖于抽象，不能依赖于具体实现")]),v._v(" "),_("p",[v._v("依赖注入写法：\n• 构造注入 (Constructor Injection) ：通过 构造函数 注入实例变量。\n• 设值注入 (Setter Injection) ：通过 Setter 方法 注入实例变量。")]),v._v(" "),_("h2",{attrs:{id:"合成-聚合复用原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#合成-聚合复用原则"}},[v._v("#")]),v._v(" 合成/聚合复用原则")]),v._v(" "),_("p",[v._v("尽量使用合成/聚合，而不是通过继承达到复用的目的")]),v._v(" "),_("p",[v._v("关键句")]),v._v(" "),_("ul",[_("li",[v._v("继承层次超过 3 次。如果这样的话,可以考虑重构你的代码,或者重新设计结构.")])]),v._v(" "),_("h2",{attrs:{id:"最少知识原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最少知识原则"}},[v._v("#")]),v._v(" 最少知识原则")]),v._v(" "),_("p",[v._v("一个软件实体应当尽可能少的与其他实体发生相互作用")]),v._v(" "),_("p",[v._v("关键句")]),v._v(" "),_("ul",[_("li",[v._v("不要和“陌生人”说话")]),v._v(" "),_("li",[v._v("只与你的直接朋友通信")]),v._v(" "),_("li",[v._v("每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。")]),v._v(" "),_("li",[v._v("一个对象对其他对象的引用应当降到最低")])]),v._v(" "),_("h2",{attrs:{id:"写前端业务的结合思考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#写前端业务的结合思考"}},[v._v("#")]),v._v(" 写前端业务的结合思考")]),v._v(" "),_("ol",[_("li",[v._v("思考页面或者组件的职责，仅实现职责，不要做多余事情，（单一职责）")]),v._v(" "),_("li",[v._v("思考职责未来拓展可能性，（开闭原则）")]),v._v(" "),_("li",[v._v("属于职责内的功能尽量内聚，仅暴露职责相关 props（接口隔离）")])])])}),[],!1,null,null,null);_.default=r.exports}}]);